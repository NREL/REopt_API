# Generated by Django 4.0.7 on 2023-03-07 20:31

import django.contrib.postgres.fields
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import job.models


class Migration(migrations.Migration):

    dependencies = [
        ('job', '0025_merge_20230202_1907'),
    ]

    operations = [
        migrations.CreateModel(
            name='BoilerInputs',
            fields=[
                ('meta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, related_name='BoilerInputs', serialize=False, to='job.apimeta')),
                ('min_mmbtu_per_hour', models.FloatField(default=0.0, help_text='Minimum thermal power size', validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('max_mmbtu_per_hour', models.FloatField(default=0.0, help_text='Maximum thermal power size', validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('efficiency', models.FloatField(default=0.8, help_text='New boiler system efficiency - conversion of fuel to usable heating thermal energy.', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('fuel_cost_per_mmbtu', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, validators=[django.core.validators.MinValueValidator(0)]), default=list, help_text='Fuel cost in [$/MMBtu]', null=True, size=None)),
                ('macrs_option_years', models.IntegerField(blank=True, choices=[(0, 'Zero'), (5, 'Five'), (7, 'Seven')], default=0, help_text='Duration over which accelerated depreciation will occur. Set to zero to disable', null=True)),
                ('macrs_bonus_fraction', models.FloatField(blank=True, default=0.0, help_text='Percent of upfront project costs to depreciate in year one in addition to scheduled depreciation', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)])),
                ('installed_cost_per_mmbtu_per_hour', models.FloatField(blank=True, default=293000.0, help_text='Thermal power-based cost', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('om_cost_per_mmbtu_per_hour', models.FloatField(blank=True, default=2930.0, help_text='Thermal power-based fixed O&M cost', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('om_cost_per_mmbtu', models.FloatField(blank=True, default=0.0, help_text='Thermal energy-based variable O&M cost', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('fuel_type', models.TextField(blank=True, choices=[('natural_gas', 'Natural Gas'), ('landfill_bio_gas', 'Landfill Bio Gas'), ('propane', 'Propane'), ('diesel_oil', 'Diesel Oil'), ('uranium', 'Uranium')], default='natural_gas', help_text='Existing boiler fuel type, one of natural_gas, landfill_bio_gas, propane, diesel_oil, uranium', null=True)),
                ('can_supply_steam_turbine', models.BooleanField(blank=True, default=True, help_text='If the boiler can supply steam to the steam turbine for electric production', null=True)),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='BoilerOutputs',
            fields=[
                ('meta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, related_name='BoilerOutputs', serialize=False, to='job.apimeta')),
                ('fuel_consumption_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_to_load_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('year_one_fuel_cost_before_tax', models.FloatField(blank=True, null=True)),
                ('thermal_to_steamturbine_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_production_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_to_storage_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('size_mmbtu_per_hour', models.FloatField(blank=True, null=True)),
                ('annual_fuel_consumption_mmbtu', models.FloatField(blank=True, null=True)),
                ('lifecycle_per_unit_prod_om_costs', models.FloatField(blank=True, null=True)),
                ('lifecycle_fuel_cost_after_tax', models.FloatField(blank=True, null=True)),
                ('annual_thermal_production_mmbtu', models.FloatField(blank=True, null=True)),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='SteamTurbineInputs',
            fields=[
                ('meta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, related_name='SteamTurbineInputs', serialize=False, to='job.apimeta')),
                ('min_kw', models.FloatField(blank=True, default=0.0, help_text='Minimum steam turbine size constraint for optimization', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000.0)])),
                ('max_kw', models.FloatField(blank=True, default=0.0, help_text='Maximum steam turbine size constraint for optimization', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000.0)])),
                ('size_class', models.IntegerField(blank=True, choices=[(0, 'Zero'), (1, 'One'), (2, 'Two'), (4, 'Four')], help_text='Steam turbine size class for using appropriate default inputs', null=True)),
                ('gearbox_generator_efficiency', models.FloatField(blank=True, help_text='Combined gearbox (if applicable) and electric motor/generator efficiency', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('inlet_steam_pressure_psig', models.FloatField(blank=True, help_text='Inlet steam pressure to the steam turbine', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(5000.0)])),
                ('inlet_steam_temperature_degF', models.FloatField(blank=True, help_text='Inlet steam temperature to the steam turbine', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1300.0)])),
                ('installed_cost_per_kw', models.FloatField(blank=True, help_text='Installed steam turbine cost in $/kW', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000.0)])),
                ('om_cost_per_kwh', models.FloatField(blank=True, help_text='Steam turbine per unit production (variable) operations and maintenance costs in $/kWh', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('outlet_steam_pressure_psig', models.FloatField(blank=True, help_text='Outlet steam pressure from the steam turbine (to the condenser or heat recovery unit)', null=True, validators=[django.core.validators.MinValueValidator(-14.7), django.core.validators.MaxValueValidator(1000.0)])),
                ('net_to_gross_electric_ratio', models.FloatField(blank=True, help_text='Efficiency factor to account for auxiliary loads such as pumps, controls, lights, etc', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('electric_produced_to_thermal_consumed_ratio', models.FloatField(blank=True, help_text='Simplified input as alternative to detailed calculations from inlet and outlet steam conditions', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('thermal_produced_to_thermal_consumed_ratio', models.FloatField(blank=True, help_text='Simplified input as alternative to detailed calculations from condensing outlet steam', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_condensing', models.BooleanField(blank=True, default=False, help_text='Steam turbine type, if it is a condensing turbine which produces no useful thermal (max electric output)')),
                ('inlet_steam_superheat_degF', models.FloatField(default=0.0, help_text='Alternative input to inlet steam temperature, this is the superheat amount (delta from T_saturation) to the steam turbine', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(700.0)])),
                ('outlet_steam_min_vapor_fraction', models.FloatField(blank=True, default=0.8, help_text='Minimum practical vapor fraction of steam at the exit of the steam turbine', validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('isentropic_efficiency', models.FloatField(blank=True, help_text='Steam turbine isentropic efficiency - uses inlet T/P and outlet T/P/X to get power out', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('om_cost_per_kw', models.FloatField(default=0.0, help_text='Annual steam turbine fixed operations and maintenance costs in $/kW', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(5000.0)])),
                ('can_net_meter', models.BooleanField(blank=True, default=False, help_text='True/False for if technology has option to participate in net metering agreement with utility. Note that a technology can only participate in either net metering or wholesale rates (not both).Note that if off-grid is true, net metering is always set to False.')),
                ('can_wholesale', models.BooleanField(blank=True, default=False, help_text='True/False for if technology has option to export energy that is compensated at the wholesale_rate. Note that a technology can only participate in either net metering or wholesale rates (not both).Note that if off-grid is true, can_wholesale is always set to False.')),
                ('can_export_beyond_nem_limit', models.BooleanField(blank=True, default=False, help_text='True/False for if technology can export energy beyond the annual site load (and be compensated for that energy at the export_rate_beyond_net_metering_limit).Note that if off-grid is true, can_export_beyond_nem_limit is always set to False.')),
                ('can_curtail', models.BooleanField(blank=True, default=False, help_text='True/False for if technology has the ability to curtail energy production.')),
                ('macrs_option_years', models.IntegerField(blank=True, choices=[(0, 'Zero'), (5, 'Five'), (7, 'Seven')], default=0, help_text='Duration over which accelerated depreciation will occur. Set to zero to disable')),
                ('macrs_bonus_fraction', models.FloatField(blank=True, default=1.0, help_text='Percent of upfront project costs to depreciate in year one in addition to scheduled depreciation', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)])),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='SteamTurbineOutputs',
            fields=[
                ('meta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, related_name='SteamTurbineOutputs', serialize=False, to='job.apimeta')),
                ('size_kw', models.FloatField(blank=True, null=True)),
                ('annual_thermal_consumption_mmbtu', models.FloatField(blank=True, null=True)),
                ('annual_electric_production_kwh', models.FloatField(blank=True, null=True)),
                ('annual_thermal_production_mmbtu', models.FloatField(blank=True, null=True)),
                ('thermal_consumption_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('electric_production_series_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('electric_to_grid_series_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('electric_to_storage_series_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('electric_to_load_series_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_to_storage_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_to_load_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.AlterField(
            model_name='electrictariffinputs',
            name='export_rate_beyond_net_metering_limit',
            field=django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, validators=[django.core.validators.MinValueValidator(0)]), blank=True, default=list, help_text='Price of electricity sold back to the grid above the site load, regardless of net metering. Can be a scalar value, which applies for all-time, or an array with time-sensitive values. If an array is input then it must have a length of 8760, 17520, or 35040. The inputed array values are up/down-sampled using mean values to match the Scenario time_steps_per_hour.', size=None),
        ),
    ]
