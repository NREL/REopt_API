# Generated by Django 3.1.8 on 2021-06-24 06:07

import django.contrib.postgres.fields
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import job.models
import picklefield.fields


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Scenario',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('run_uuid', models.UUIDField(unique=True)),
                ('api_version', models.IntegerField(default=2)),
                ('user_uuid', models.TextField(blank=True, help_text='The assigned unique ID of a signed in REopt user.', null=True)),
                ('webtool_uuid', models.TextField(blank=True, help_text="The unique ID of a scenario created by the REopt Lite Webtool. Note that this ID can be shared by several REopt Lite API Scenarios (for example when users select a 'Resilience' analysis more than one REopt API Scenario is created).", null=True)),
                ('job_type', models.TextField(default='developer.nrel.gov')),
                ('description', models.TextField(blank=True)),
                ('status', models.TextField(blank=True)),
                ('created', models.DateTimeField(auto_now_add=True)),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='ElectricLoadInputs',
            fields=[
                ('scenario', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, serialize=False, to='job.scenario')),
                ('annual_kwh', models.FloatField(blank=True, help_text="Annual site energy consumption from electricity, in kWh, used to scale simulated default building load profile for the site's climate zone", null=True, validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(100000000)])),
                ('doe_reference_name', models.TextField(blank=True, choices=[('FastFoodRest', 'Fastfoodrest'), ('FullServiceRest', 'Fullservicerest'), ('Hospital', 'Hospital'), ('LargeHotel', 'Largehotel'), ('LargeOffice', 'Largeoffice'), ('MediumOffice', 'Mediumoffice'), ('MidriseApartment', 'Midriseapartment'), ('Outpatient', 'Outpatient'), ('PrimarySchool', 'Primaryschool'), ('RetailStore', 'Retailstore'), ('SecondarySchool', 'Secondaryschool'), ('SmallHotel', 'Smallhotel'), ('SmallOffice', 'Smalloffice'), ('StripMall', 'Stripmall'), ('Supermarket', 'Supermarket'), ('Warehouse', 'Warehouse'), ('FlatLoad', 'Flatload'), ('FlatLoad_24_5', 'Flatload 24 5'), ('FlatLoad_16_7', 'Flatload 16 7'), ('FlatLoad_16_5', 'Flatload 16 5'), ('FlatLoad_8_7', 'Flatload 8 7'), ('FlatLoad_8_5', 'Flatload 8 5')], help_text="Simulated load profile from DOE <a href='https: //energy.gov/eere/buildings/commercial-reference-buildings' target='blank'>Commercial Reference Buildings</a>")),
                ('year', models.IntegerField(blank=True, default=2020, help_text="Year of Custom Load Profile. If a custom load profile is uploaded via the loads_kw parameter, it is important that this year correlates with the load profile so that weekdays/weekends are determined correctly for the utility rate tariff. If a DOE Reference Building profile (aka 'simulated' profile) is used, the year is set to 2017 since the DOE profiles start on a Sunday.", null=True, validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(9999)])),
                ('monthly_totals_kwh', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, default=100000000.0, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000000.0)]), blank=True, default=list, help_text="Monthly site energy consumption from electricity series (an array 12 entries long), in kWh, used to scale simulated default building load profile for the site's climate zone", null=True, size=None)),
                ('loads_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, help_text='Typical load over all hours in one year. Must be hourly (8,760 samples), 30 minute (17,520 samples), or 15 minute (35,040 samples). All non-net load values must be greater than or equal to zero. ', null=True, size=None)),
                ('critical_loads_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, help_text='Critical load during an outage period. Must be hourly (8,760 samples), 30 minute (17,520 samples),or 15 minute (35,040 samples). All non-net load values must be greater than or equal to zero.', null=True, size=None)),
                ('loads_kw_is_net', models.BooleanField(blank=True, default=True, help_text='If there is existing PV, must specify whether provided load is the net load after existing PV or not.', null=True)),
                ('critical_loads_kw_is_net', models.BooleanField(blank=True, default=False, help_text='If there is existing PV, must specify whether provided load is the net load after existing PV or not.', null=True)),
                ('outage_start_time_step', models.IntegerField(blank=True, help_text='Time step that grid outage starts. Must be less than outage_end.', null=True, validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(35040)])),
                ('outage_end_time_step', models.IntegerField(blank=True, help_text='Time step that grid outage ends. Must be greater than outage_start.', null=True, validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(35040)])),
                ('critical_load_pct', models.FloatField(blank=True, default=0.5, help_text='Critical load factor is multiplied by the typical load to determine the critical load that must be met during an outage. Value must be between zero and one, inclusive.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(2)])),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='ElectricTariffInputs',
            fields=[
                ('scenario', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, serialize=False, to='job.scenario')),
                ('monthly_demand_rates', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, help_text='Array (length of 12) of blended demand charges in dollars per kW', null=True, size=12)),
                ('monthly_energy_rates', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, help_text='Array (length of 12) of blended energy rates in dollars per kWh.', null=True, size=12)),
                ('urdb_label', models.TextField(blank=True, help_text="Label attribute of utility rate structure from <a href='https://openei.org/services/doc/rest/util_rates/?version=3' target='blank'>Utility Rate Database API</a>")),
                ('urdb_response', picklefield.fields.PickledObjectField(blank=True, editable=False, help_text="Utility rate structure from <a href='https://openei.org/services/doc/rest/util_rates/?version=3' target='blank'>Utility Rate Database API</a>", null=True)),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='FinancialInputs',
            fields=[
                ('scenario', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, serialize=False, to='job.scenario')),
                ('analysis_years', models.IntegerField(blank=True, default=25, help_text='Analysis period in years. Must be integer.', null=True, validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(75)])),
                ('elec_cost_escalation_pct', models.FloatField(blank=True, default=0.023, help_text='Annual nominal utility electricity cost escalation rate.', null=True, validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)])),
                ('offtaker_discount_pct', models.FloatField(blank=True, default=0.083, help_text='Nominal energy offtaker discount rate. In single ownership model the offtaker is also the generation owner.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)])),
                ('offtaker_tax_pct', models.FloatField(blank=True, default=0.26, help_text='Host tax rate', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(0.999)])),
                ('om_cost_escalation_pct', models.FloatField(blank=True, default=0.025, help_text='Annual nominal O&M cost escalation rate', null=True, validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)])),
                ('owner_discount_pct', models.FloatField(blank=True, default=0.083, help_text='Nominal generation owner discount rate. Used for two party financing model. In two party ownership model the offtaker does not own the generator(s).', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)])),
                ('owner_tax_pct', models.FloatField(blank=True, default=0.26, help_text='Generation owner tax rate. Used for two party financing model. In two party ownership model the offtaker does not own the generator(s).', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(0.999)])),
                ('third_party_ownership', models.BooleanField(blank=True, default=False, help_text='Specify if ownership model is direct ownership or two party. In two party model the offtaker does not purcharse the generation technologies, but pays the generation owner for energy from the generator(s).', null=True)),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='Settings',
            fields=[
                ('scenario', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, serialize=False, to='job.scenario')),
                ('timeout_seconds', models.IntegerField(default=420, help_text='The number of seconds allowed before the optimization times out.', validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(420)])),
                ('time_steps_per_hour', models.IntegerField(choices=[(1, '1'), (2, '2'), (3, '4')], default=1, help_text='The number of time steps per hour in the REopt model.')),
                ('optimality_tolerance', models.FloatField(default=0.001, help_text="The threshold for the difference between the solution's objective value and the best possible value at which the solver terminates", validators=[django.core.validators.MinValueValidator(1e-05), django.core.validators.MaxValueValidator(10)])),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='SiteInputs',
            fields=[
                ('scenario', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, serialize=False, to='job.scenario')),
                ('latitude', models.FloatField(help_text='The approximate latitude of the site in decimal degrees.', validators=[django.core.validators.MinValueValidator(-90), django.core.validators.MaxValueValidator(90)])),
                ('longitude', models.FloatField(help_text='The approximate longitude of the site in decimal degrees.', validators=[django.core.validators.MinValueValidator(-180), django.core.validators.MaxValueValidator(180)])),
                ('land_acres', models.FloatField(blank=True, help_text='Land area in acres available for PV panel siting', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000)])),
                ('roof_squarefeet', models.FloatField(blank=True, help_text='Area of roof in square feet available for PV siting', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000)])),
            ],
            bases=(job.models.BaseModel, models.Model),
        ),
    ]
