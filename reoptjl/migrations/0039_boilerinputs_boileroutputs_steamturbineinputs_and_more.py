# Generated by Django 4.0.7 on 2024-02-01 16:44

import django.contrib.postgres.fields
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import reoptjl.models


class Migration(migrations.Migration):

    dependencies = [
        ('reoptjl', '0038_merge_20231027_1950'),
    ]

    operations = [
        migrations.CreateModel(
            name='BoilerInputs',
            fields=[
                ('meta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, related_name='BoilerInputs', serialize=False, to='reoptjl.apimeta')),
                ('min_mmbtu_per_hour', models.FloatField(blank=True, default=0.0, help_text='Minimum thermal power size', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('max_mmbtu_per_hour', models.FloatField(blank=True, default=10000000.0, help_text='Maximum thermal power size', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('efficiency', models.FloatField(blank=True, default=0.8, help_text='New boiler system efficiency - conversion of fuel to usable heating thermal energy.', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('fuel_cost_per_mmbtu', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, validators=[django.core.validators.MinValueValidator(0)]), default=list, help_text='Fuel cost in [$/MMBtu]', null=True, size=None)),
                ('macrs_option_years', models.IntegerField(blank=True, choices=[(0, 'Zero'), (5, 'Five'), (7, 'Seven')], default=0, help_text='Duration over which accelerated depreciation will occur. Set to zero to disable', null=True)),
                ('macrs_bonus_fraction', models.FloatField(blank=True, default=0.0, help_text='Percent of upfront project costs to depreciate in year one in addition to scheduled depreciation', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)])),
                ('installed_cost_per_mmbtu_per_hour', models.FloatField(blank=True, default=293000.0, help_text='Thermal power-based cost', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('om_cost_per_mmbtu_per_hour', models.FloatField(blank=True, default=2930.0, help_text='Thermal power-based fixed O&M cost', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('om_cost_per_mmbtu', models.FloatField(blank=True, default=0.0, help_text='Thermal energy-based variable O&M cost', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000000.0)])),
                ('fuel_type', models.TextField(blank=True, choices=[('natural_gas', 'Natural Gas'), ('landfill_bio_gas', 'Landfill Bio Gas'), ('propane', 'Propane'), ('diesel_oil', 'Diesel Oil'), ('uranium', 'Uranium')], default='natural_gas', help_text='Existing boiler fuel type, one of natural_gas, landfill_bio_gas, propane, diesel_oil, uranium', null=True)),
                ('can_supply_steam_turbine', models.BooleanField(blank=True, default=True, help_text='If the boiler can supply steam to the steam turbine for electric production', null=True)),
            ],
            bases=(reoptjl.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='BoilerOutputs',
            fields=[
                ('meta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, related_name='BoilerOutputs', serialize=False, to='reoptjl.apimeta')),
                ('fuel_consumption_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_to_load_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('year_one_fuel_cost_before_tax', models.FloatField(blank=True, null=True)),
                ('thermal_to_steamturbine_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_production_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_to_storage_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('size_mmbtu_per_hour', models.FloatField(blank=True, null=True)),
                ('annual_fuel_consumption_mmbtu', models.FloatField(blank=True, null=True)),
                ('lifecycle_per_unit_prod_om_costs', models.FloatField(blank=True, null=True)),
                ('lifecycle_fuel_cost_after_tax', models.FloatField(blank=True, null=True)),
                ('annual_thermal_production_mmbtu', models.FloatField(blank=True, null=True)),
            ],
            bases=(reoptjl.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='SteamTurbineInputs',
            fields=[
                ('meta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, related_name='SteamTurbineInputs', serialize=False, to='reoptjl.apimeta')),
                ('min_kw', models.FloatField(blank=True, default=0.0, help_text='Minimum steam turbine size constraint for optimization', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000.0)])),
                ('max_kw', models.FloatField(blank=True, default=100000000.0, help_text='Maximum steam turbine size constraint for optimization', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000.0)])),
                ('size_class', models.IntegerField(blank=True, choices=[(0, 'Zero'), (1, 'One'), (2, 'Two'), (4, 'Four')], help_text='Steam turbine size class for using appropriate default inputs', null=True)),
                ('gearbox_generator_efficiency', models.FloatField(blank=True, help_text='Combined gearbox (if applicable) and electric motor/generator efficiency', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('inlet_steam_pressure_psig', models.FloatField(blank=True, help_text='Inlet steam pressure to the steam turbine', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(5000.0)])),
                ('inlet_steam_temperature_degF', models.FloatField(blank=True, help_text='Inlet steam temperature to the steam turbine', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1300.0)])),
                ('installed_cost_per_kw', models.FloatField(blank=True, help_text='Installed steam turbine cost in $/kW', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000.0)])),
                ('om_cost_per_kwh', models.FloatField(blank=True, help_text='Steam turbine per unit production (variable) operations and maintenance costs in $/kWh', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('outlet_steam_pressure_psig', models.FloatField(blank=True, help_text='Outlet steam pressure from the steam turbine (to the condenser or heat recovery unit)', null=True, validators=[django.core.validators.MinValueValidator(-14.7), django.core.validators.MaxValueValidator(1000.0)])),
                ('net_to_gross_electric_ratio', models.FloatField(blank=True, help_text='Efficiency factor to account for auxiliary loads such as pumps, controls, lights, etc', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('electric_produced_to_thermal_consumed_ratio', models.FloatField(blank=True, help_text='Simplified input as alternative to detailed calculations from inlet and outlet steam conditions', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('thermal_produced_to_thermal_consumed_ratio', models.FloatField(blank=True, help_text='Simplified input as alternative to detailed calculations from condensing outlet steam', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_condensing', models.BooleanField(blank=True, default=False, help_text='Steam turbine type, if it is a condensing turbine which produces no useful thermal (max electric output)', null=True)),
                ('inlet_steam_superheat_degF', models.FloatField(blank=True, default=0.0, help_text='Alternative input to inlet steam temperature, this is the superheat amount (delta from T_saturation) to the steam turbine', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(700.0)])),
                ('outlet_steam_min_vapor_fraction', models.FloatField(blank=True, default=0.8, help_text='Minimum practical vapor fraction of steam at the exit of the steam turbine', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('isentropic_efficiency', models.FloatField(blank=True, help_text='Steam turbine isentropic efficiency - uses inlet T/P and outlet T/P/X to get power out', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('om_cost_per_kw', models.FloatField(blank=True, default=0.0, help_text='Annual steam turbine fixed operations and maintenance costs in $/kW', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(5000.0)])),
                ('can_net_meter', models.BooleanField(blank=True, default=False, help_text='True/False for if technology has option to participate in net metering agreement with utility. Note that a technology can only participate in either net metering or wholesale rates (not both).Note that if off-grid is true, net metering is always set to False.', null=True)),
                ('can_wholesale', models.BooleanField(blank=True, default=False, help_text='True/False for if technology has option to export energy that is compensated at the wholesale_rate. Note that a technology can only participate in either net metering or wholesale rates (not both).Note that if off-grid is true, can_wholesale is always set to False.', null=True)),
                ('can_export_beyond_nem_limit', models.BooleanField(blank=True, default=False, help_text='True/False for if technology can export energy beyond the annual site load (and be compensated for that energy at the export_rate_beyond_net_metering_limit).Note that if off-grid is true, can_export_beyond_nem_limit is always set to False.', null=True)),
                ('can_curtail', models.BooleanField(blank=True, default=False, help_text='True/False for if technology has the ability to curtail energy production.', null=True)),
                ('macrs_option_years', models.IntegerField(blank=True, choices=[(0, 'Zero'), (5, 'Five'), (7, 'Seven')], default=0, help_text='Duration over which accelerated depreciation will occur. Set to zero to disable', null=True)),
                ('macrs_bonus_fraction', models.FloatField(blank=True, default=1.0, help_text='Percent of upfront project costs to depreciate in year one in addition to scheduled depreciation', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)])),
            ],
            bases=(reoptjl.models.BaseModel, models.Model),
        ),
        migrations.CreateModel(
            name='SteamTurbineOutputs',
            fields=[
                ('meta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, primary_key=True, related_name='SteamTurbineOutputs', serialize=False, to='reoptjl.apimeta')),
                ('size_kw', models.FloatField(blank=True, null=True)),
                ('annual_thermal_consumption_mmbtu', models.FloatField(blank=True, null=True)),
                ('annual_electric_production_kwh', models.FloatField(blank=True, null=True)),
                ('annual_thermal_production_mmbtu', models.FloatField(blank=True, null=True)),
                ('thermal_consumption_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('electric_production_series_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('electric_to_grid_series_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('electric_to_storage_series_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('electric_to_load_series_kw', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_to_storage_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
                ('thermal_to_load_series_mmbtu_per_hour', django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, size=None)),
            ],
            bases=(reoptjl.models.BaseModel, models.Model),
        ),
        migrations.RenameField(
            model_name='electricutilityoutputs',
            old_name='distance_to_emissions_region_meters',
            new_name='distance_to_avert_emissions_region_meters',
        ),
        migrations.RemoveField(
            model_name='electricutilityinputs',
            name='emissions_region',
        ),
        migrations.RemoveField(
            model_name='electricutilityoutputs',
            name='emissions_region',
        ),
        migrations.AddField(
            model_name='apimeta',
            name='api_key',
            field=models.TextField(blank=True, default='', help_text='NREL Developer API key of the user'),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='allow_simultaneous_export_import',
            field=models.BooleanField(blank=True, default=True, help_text='If true the site has two meters (in effect).'),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='avert_emissions_region',
            field=models.TextField(blank=True, help_text="Name of the AVERT emissions region to use. Options are: 'California', 'Central', 'Florida', 'Mid-Atlantic', 'Midwest', 'Carolinas', 'New England', 'Northwest', 'New York', 'Rocky Mountains', 'Southeast', 'Southwest', 'Tennessee', 'Texas', 'Alaska', 'Hawaii (except Oahu)', 'Hawaii (Oahu)'. If emissions_factor_series_lb_<pollutant>_per_kwh inputs are not provided, avert_emissions_region overrides latitude and longitude in determining emissions factors."),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='cambium_grid_level',
            field=models.TextField(blank=True, default='enduse', help_text="Impacts grid climate emissions calculation. Options: ['enduse' or 'busbar']. Busbar refers to point where bulk generating stations connect to grid; enduse refers to point of consumption (includes distribution loss rate)."),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='cambium_levelization_years',
            field=models.IntegerField(blank=True, help_text='Expected lifetime or analysis period of the intervention being studied. Emissions will be averaged over this period. Default: analysis_years (from Financial struct)', null=True, validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(100)]),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='cambium_location_type',
            field=models.TextField(blank=True, default='States', help_text="Geographic boundary at which emissions are calculated. Options: ['Nations', 'GEA Regions', 'States']."),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='cambium_metric_col',
            field=models.TextField(blank=True, default='lrmer_co2e', help_text='Emissions metric used. Default is Long-run marginal emissions rate for CO2-equivalant, combined combustion and pre-combustion emissions rates. Options: See metric definitions and names in the Cambium documentation.'),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='cambium_scenario',
            field=models.TextField(blank=True, default='Mid-case', help_text="Cambium Scenario for evolution of electricity sector (see Cambium documentation for descriptions).Options: ['Mid-case', 'Low Renewable Energy and Battery Costs', 'High Renewable Energy and Battery Costs', 'Electricifcation', 'Low Natural Gas Price', 'High Natural Gas Price', 'Mid-case with 95% Decarbonization by 2050', 'Mid-case with 100% Decarbonization by 2035', 'Mid-case (with tax credit phaseout)', 'Low Renewable Energy and Battery Costs (with tax credit phaseout)']"),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='cambium_start_year',
            field=models.IntegerField(blank=True, default=2024, help_text='First year of operation of system. Emissions will be levelized starting in this year for the duration of cambium_levelization_years.', validators=[django.core.validators.MinValueValidator(2023), django.core.validators.MaxValueValidator(2050)]),
        ),
        migrations.AddField(
            model_name='electricutilityinputs',
            name='co2_from_avert',
            field=models.BooleanField(blank=True, default=False, help_text="Default is to use Cambium data for CO2 grid emissions. Set to `true` to instead use data from the EPA's AVERT database. "),
        ),
        migrations.AddField(
            model_name='electricutilityoutputs',
            name='avert_emissions_region',
            field=models.TextField(blank=True, help_text="Name of the AVERT emissions region. Determined from site longitude and latitude if avert_emissions_region and emissions_factor_series_lb_<pollutant>_per_kwh inputs were not provided. Used to populate health emissions factors by default and climate emissions factors if co2_from_avert is set to true.Can be one of: [California', 'Central', 'Florida', 'Mid-Atlantic', 'Midwest', 'Carolinas', 'New England',  'Northwest', 'New York', 'Rocky Mountains', 'Southeast', 'Southwest', 'Tennessee', 'Texas','Alaska', 'Hawaii (except Oahu)', 'Hawaii (Oahu)'] "),
        ),
        migrations.AddField(
            model_name='electricutilityoutputs',
            name='cambium_emissions_region',
            field=models.TextField(blank=True, help_text='Name of the Cambium emissions region used for climate emissions for grid electricity. Determined from site longitude and latitude and the cambium_location_type if custom emissions_factor_series_lb_CO2_per_kwh not provided and co2_from_avert is false.'),
        ),
        migrations.AddField(
            model_name='existingboilerinputs',
            name='can_supply_steam_turbine',
            field=models.BooleanField(blank=True, default=False, help_text='If the boiler can supply steam to the steam turbine for electric production', null=True),
        ),
        migrations.AddField(
            model_name='existingboileroutputs',
            name='annual_fuel_consumption_mmbtu_bau',
            field=models.FloatField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='existingboileroutputs',
            name='annual_thermal_production_mmbtu_bau',
            field=models.FloatField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='existingboileroutputs',
            name='year_one_fuel_cost_before_tax_bau',
            field=models.FloatField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='existingchilleroutputs',
            name='annual_electric_consumption_kwh_bau',
            field=models.FloatField(blank=True, help_text='Annual chiller electric consumption for BAU case [kWh]', null=True),
        ),
        migrations.AddField(
            model_name='existingchilleroutputs',
            name='annual_thermal_production_tonhour_bau',
            field=models.FloatField(blank=True, help_text='Annual chiller thermal production for BAU case [Ton Hour]', null=True),
        ),
        migrations.AddField(
            model_name='financialinputs',
            name='boiler_fuel_cost_escalation_rate_fraction',
            field=models.FloatField(blank=True, default=0.015, help_text='Annual nominal boiler fuel cost escalation rate', validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AddField(
            model_name='financialinputs',
            name='chp_fuel_cost_escalation_rate_fraction',
            field=models.FloatField(blank=True, default=0.015, help_text='Annual nominal chp fuel cost escalation rate', validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AddField(
            model_name='financialinputs',
            name='existing_boiler_fuel_cost_escalation_rate_fraction',
            field=models.FloatField(blank=True, default=0.015, help_text='Annual nominal existing boiler fuel cost escalation rate', validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AddField(
            model_name='financialinputs',
            name='generator_fuel_cost_escalation_rate_fraction',
            field=models.FloatField(blank=True, default=0.012, help_text='Annual nominal boiler fuel cost escalation rate', validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AddField(
            model_name='financialoutputs',
            name='lifecycle_MG_upgrade_and_fuel_cost_bau',
            field=models.FloatField(blank=True, help_text='BAU Component of lifecycle costs (LCC). This is the cost to upgrade generation and storage technologies to be included in microgridplus present value of microgrid fuel costs.', null=True),
        ),
        migrations.AddField(
            model_name='financialoutputs',
            name='lifecycle_chp_standby_cost_after_tax_bau',
            field=models.FloatField(blank=True, help_text='BAU Component of lifecycle costs (LCC). This value is the present value of all CHP standby charges, after tax.', null=True),
        ),
        migrations.AddField(
            model_name='financialoutputs',
            name='lifecycle_elecbill_after_tax_bau',
            field=models.FloatField(blank=True, help_text='BAU Component of lifecycle costs (LCC). This value is the present value of all electric utility charges, after tax.', null=True),
        ),
        migrations.AddField(
            model_name='financialoutputs',
            name='lifecycle_fuel_costs_after_tax_bau',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). This value is the present value of all fuel costs over the analysis period, after tax in the BAU case.', null=True),
        ),
        migrations.AddField(
            model_name='financialoutputs',
            name='lifecycle_outage_cost_bau',
            field=models.FloatField(blank=True, help_text='BAU Component of lifecycle costs (LCC). Expected outage cost.', null=True),
        ),
        migrations.AddField(
            model_name='financialoutputs',
            name='lifecycle_production_incentive_after_tax_bau',
            field=models.FloatField(blank=True, help_text='BAU Component of lifecycle costs (LCC). This value is the present value of all production-based incentives, after tax.', null=True),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='aux_cooler_installed_cost_per_ton',
            field=models.FloatField(blank=True, default=400.0, help_text='Installed cost of auxiliary cooler (e.g. cooling tower) for hybrid ghx in $/ton based on peak thermal production', validators=[django.core.validators.MinValueValidator(1.0), django.core.validators.MaxValueValidator(1000000.0)]),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='aux_heater_installed_cost_per_mmbtu_per_hr',
            field=models.FloatField(blank=True, default=26000.0, help_text='Installed cost of auxiliary heater for hybrid ghx in $/MMBtu/hr based on peak thermal production.', validators=[django.core.validators.MinValueValidator(1.0), django.core.validators.MaxValueValidator(1000000.0)]),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='aux_heater_type',
            field=models.TextField(blank=True, help_text='This field only accepts "electric" as the auxillary heater type. User does not need to provide this information.', null=True),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='aux_unit_capacity_sizing_factor_on_peak_load',
            field=models.FloatField(blank=True, default=1.2, help_text='Factor on peak heating and cooling load served by the auxiliary heater/cooler used for determining heater/cooler installed capacity', validators=[django.core.validators.MinValueValidator(1.0), django.core.validators.MaxValueValidator(5.0)]),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='avoided_capex_by_ghp_present_value',
            field=models.FloatField(blank=True, default=0.0, help_text='Expected cost of HVAC upgrades avoided due to GHP tech over Financial.analysis_years', validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000000.0)]),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='ghx_only_capital_cost',
            field=models.IntegerField(blank=True, help_text='Capital cost of geothermal heat exchanger which is calculated by REopt automatically. User does not need to provide this input.', null=True, validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(100000000.0)]),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='ghx_useful_life_years',
            field=models.IntegerField(blank=True, default=50, help_text='Lifetime of geothermal heat exchanger being modeled in years. This is used to calculate residual value at end of REopt analysis period. If this value is less than Financial.analysis_years, its set to Financial.analysis_years.', validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(75)]),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='installed_cost_wwhp_cooling_pump_per_ton',
            field=models.FloatField(blank=True, default=700.0, help_text='Installed WWHP cooling heat pump cost in $/ton (based on peak cooling thermal load)', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000.0)]),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='installed_cost_wwhp_heating_pump_per_ton',
            field=models.FloatField(blank=True, default=700.0, help_text='Installed WWHP heating heat pump cost in $/ton (based on peak heating thermal load)', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000.0)]),
        ),
        migrations.AddField(
            model_name='ghpinputs',
            name='is_ghx_hybrid',
            field=models.BooleanField(blank=True, help_text='REopt derived indicator for hybrid Ghx', null=True),
        ),
        migrations.AddField(
            model_name='ghpoutputs',
            name='ghx_residual_value_present_value',
            field=models.FloatField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='ghpoutputs',
            name='size_wwhp_cooling_pump_ton',
            field=models.FloatField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='ghpoutputs',
            name='size_wwhp_heating_pump_ton',
            field=models.FloatField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='outageoutputs',
            name='critical_loads_per_outage_series_kw',
            field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, size=None), blank=True, default=list, size=None), blank=True, default=list, help_text='The critical load in each outage time step for each outage start time and duration. Outage duration changes along the first dimension, outage start time step along the second, and time step in outage along the third.', size=None),
        ),
        migrations.AddField(
            model_name='outageoutputs',
            name='electric_storage_microgrid_upgraded',
            field=models.BooleanField(blank=True, help_text='True/False for if ElectricStorage is included in the microgrid.', null=True),
        ),
        migrations.AddField(
            model_name='outageoutputs',
            name='soc_series_fraction',
            field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, size=None), blank=True, default=list, size=None), blank=True, default=list, help_text='Array of storage state of charge (SOC) in every outage modeled. Outage duration changes along the first dimension, outage start time changes along the second dimension, and hour within outage changes along the third dimension.', size=None),
        ),
        migrations.AddField(
            model_name='outageoutputs',
            name='wind_curtailed_series_kw',
            field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, size=None), blank=True, default=list, size=None), blank=True, default=list, help_text='Array of Wind power curtailed in every outage modeled. Outage duration changes along the first dimension, outage start time changes along the second dimension, and hour within outage changes along the third dimension.', size=None),
        ),
        migrations.AddField(
            model_name='outageoutputs',
            name='wind_microgrid_size_kw',
            field=models.FloatField(blank=True, help_text='Optimal Wind capacity included in the microgrid.', null=True),
        ),
        migrations.AddField(
            model_name='outageoutputs',
            name='wind_microgrid_upgrade_cost',
            field=models.FloatField(blank=True, help_text='Capital cost of including the Wind system in the microgrid.', null=True),
        ),
        migrations.AddField(
            model_name='outageoutputs',
            name='wind_to_load_series_kw',
            field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, size=None), blank=True, default=list, size=None), blank=True, default=list, help_text='Array of Wind power used to meet load in every outage modeled. Outage duration changes along the first dimension, outage start time changes along the second dimension, and hour within outage changes along the third dimension.', size=None),
        ),
        migrations.AddField(
            model_name='outageoutputs',
            name='wind_to_storage_series_kw',
            field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True), blank=True, default=list, size=None), blank=True, default=list, size=None), blank=True, default=list, help_text='Array of Wind power sent to the battery in every outage modeled. Outage duration changes along the first dimension, outage start time changes along the second dimension, and hour within outage changes along the third dimension.', size=None),
        ),
        migrations.AlterField(
            model_name='chpinputs',
            name='size_class',
            field=models.IntegerField(blank=True, help_text='CHP size class. Must be an integer value between 0 and 7', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(7)]),
        ),
        migrations.AlterField(
            model_name='electricloadinputs',
            name='critical_load_fraction',
            field=models.FloatField(blank=True, default=0.5, help_text='Critical load factor is multiplied by the typical load to determine the critical load that must be met during an outage. Value must be between zero and one, inclusive.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(2)]),
        ),
        migrations.AlterField(
            model_name='electricloadinputs',
            name='critical_loads_kw_is_net',
            field=models.BooleanField(blank=True, default=False, help_text='If there is existing PV, must specify whether provided load is the net load after existing PV or not.'),
        ),
        migrations.AlterField(
            model_name='electricloadinputs',
            name='loads_kw_is_net',
            field=models.BooleanField(blank=True, default=True, help_text='If there is existing PV, must specify whether provided load is the net load after existing PV or not.'),
        ),
        migrations.AlterField(
            model_name='electricstorageinputs',
            name='installed_cost_per_kw',
            field=models.FloatField(blank=True, default=910.0, help_text='Total upfront battery power capacity costs (e.g. inverter and balance of power systems)', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(10000.0)]),
        ),
        migrations.AlterField(
            model_name='electricstorageinputs',
            name='installed_cost_per_kwh',
            field=models.FloatField(blank=True, default=455.0, help_text='Total upfront battery costs', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(10000.0)]),
        ),
        migrations.AlterField(
            model_name='electricstorageinputs',
            name='replace_cost_per_kw',
            field=models.FloatField(blank=True, default=715.0, help_text='Battery power capacity replacement cost at time of replacement year', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(10000.0)]),
        ),
        migrations.AlterField(
            model_name='electricstorageinputs',
            name='replace_cost_per_kwh',
            field=models.FloatField(blank=True, default=318.0, help_text='Battery energy capacity replacement cost at time of replacement year', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(10000.0)]),
        ),
        migrations.AlterField(
            model_name='electrictariffinputs',
            name='export_rate_beyond_net_metering_limit',
            field=django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, validators=[django.core.validators.MinValueValidator(0)]), blank=True, default=list, help_text='Price of electricity sold back to the grid above the site load, regardless of net metering. Can be a scalar value, which applies for all-time, or an array with time-sensitive values. If an array is input then it must have a length of 8760, 17520, or 35040. The inputed array values are up/down-sampled using mean values to match the Scenario time_steps_per_hour.', size=None),
        ),
        migrations.AlterField(
            model_name='electrictariffoutputs',
            name='year_one_export_benefit_before_tax',
            field=models.FloatField(blank=True, help_text='Optimal year one value of exported energy. A positive value indicates a benefit.', null=True),
        ),
        migrations.AlterField(
            model_name='electrictariffoutputs',
            name='year_one_export_benefit_before_tax_bau',
            field=models.FloatField(blank=True, help_text='Business as usual year one value of exported energy. A positive value indicates a benefit.', null=True),
        ),
        migrations.AlterField(
            model_name='electricutilityinputs',
            name='emissions_factor_CO2_decrease_fraction',
            field=models.FloatField(blank=True, help_text='Not applied with use of Cambium data for climate emissions. Annual percent decrease in the total annual CO2 emissions rate of the grid. A negative value indicates an annual increase.', null=True, validators=[django.core.validators.MinValueValidator(-3), django.core.validators.MaxValueValidator(3)]),
        ),
        migrations.AlterField(
            model_name='electricutilityinputs',
            name='emissions_factor_NOx_decrease_fraction',
            field=models.FloatField(blank=True, default=0.02163, help_text='Annual percent decrease in the total annual NOx marginal emissions rate of the grid. A negative value indicates an annual increase.', null=True, validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='electricutilityinputs',
            name='emissions_factor_PM25_decrease_fraction',
            field=models.FloatField(blank=True, default=0.02163, help_text='Annual percent decrease in the total annual PM2.5 marginal emissions rate of the grid. A negative value indicates an annual increase.', null=True, validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='electricutilityinputs',
            name='emissions_factor_SO2_decrease_fraction',
            field=models.FloatField(blank=True, default=0.02163, help_text='Annual percent decrease in the total annual SO2 marginal emissions rate of the grid. A negative value indicates an annual increase.', null=True, validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='existingchilleroutputs',
            name='annual_thermal_production_tonhour',
            field=models.FloatField(blank=True, help_text='Annual chiller thermal production [Ton Hour]', null=True),
        ),
        migrations.AlterField(
            model_name='financialinputs',
            name='elec_cost_escalation_rate_fraction',
            field=models.FloatField(blank=True, default=0.017, help_text='Annual nominal utility electricity cost escalation rate.', validators=[django.core.validators.MinValueValidator(-1), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='financialinputs',
            name='offtaker_discount_rate_fraction',
            field=models.FloatField(blank=True, default=0.0638, help_text='Nominal energy offtaker discount rate. In single ownership model the offtaker is also the generation owner.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='financialinputs',
            name='owner_discount_rate_fraction',
            field=models.FloatField(blank=True, default=0.0638, help_text='Nominal generation owner discount rate. Used for two party financing model. In two party ownership model the offtaker does not own the generator(s).', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='electric_efficiency_full_load',
            field=models.FloatField(blank=True, default=0.322, help_text='Electric efficiency of the generator running at full load.', validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='emissions_factor_lb_CO2_per_gal',
            field=models.FloatField(blank=True, default=22.58, help_text='Pounds of CO2e emitted per gallon of generator fuel burned.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(10000.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='emissions_factor_lb_NOx_per_gal',
            field=models.FloatField(blank=True, default=0.0775544, help_text='Pounds of NOx emitted per gallon of generator fuel burned.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(10000.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='emissions_factor_lb_PM25_per_gal',
            field=models.FloatField(blank=True, default=0.0, help_text='Pounds of PM2.5 emitted per gallon of generator fuel burned.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(10000.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='emissions_factor_lb_SO2_per_gal',
            field=models.FloatField(blank=True, default=0.040020476, help_text='Pounds of SO2 emitted per gallon of generator fuel burned.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(10000.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='installed_cost_per_kw',
            field=models.FloatField(blank=True, help_text='Installed diesel generator cost in $/kW', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000.0)]),
        ),
        migrations.AlterField(
            model_name='ghpinputs',
            name='building_sqft',
            field=models.FloatField(help_text='Building square footage for GHP/HVAC cost calculations', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100000000.0)]),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='installed_cost_per_kw',
            field=models.FloatField(blank=True, default=1790, help_text='Installed PV cost in $/kW', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000.0)]),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='om_cost_per_kw',
            field=models.FloatField(blank=True, default=18, help_text='Annual PV operations and maintenance costs in $/kW', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000.0)]),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='tilt',
            field=models.FloatField(blank=True, help_text='PV system tilt. If PV system type is rooftop-fixed, then tilt=10 degrees, else tilt=20 degrees', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(90)]),
        ),
        migrations.AlterField(
            model_name='siteinputs',
            name='min_resil_time_steps',
            field=models.IntegerField(blank=True, help_text='The minimum number consecutive timesteps that load must be fully met once an outage begins. Only applies to multiple outage modeling using inputs outage_start_time_steps and outage_durations.If no value is provided, will default to max([ElectricUtility].outage_durations).', null=True, validators=[django.core.validators.MinValueValidator(0)]),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='annual_emissions_from_fuelburn_tonnes_CO2',
            field=models.FloatField(blank=True, help_text="Total tons of CO2e emissions associated with the site's onsite fuel burn in an average year.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='annual_emissions_from_fuelburn_tonnes_CO2_bau',
            field=models.FloatField(blank=True, help_text="Total tons of CO2e emissions associated with the site's onsite fuel burn in an average year in the BAU case.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='annual_emissions_tonnes_CO2',
            field=models.FloatField(blank=True, help_text="Average annual total tons of emissions associated with the site's grid-purchased electricity and on-site fuel consumption.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='annual_emissions_tonnes_CO2_bau',
            field=models.FloatField(blank=True, help_text="Total tons of CO2e emissions associated with the site's energy consumption in an average year in the BAU case.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='annual_emissions_tonnes_NOx',
            field=models.FloatField(blank=True, help_text="Average annual total tons of emissions associated with the site's grid-purchased electricity and on-site fuel consumption.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='annual_emissions_tonnes_PM25',
            field=models.FloatField(blank=True, help_text="Average annual total tons of emissions associated with the site's grid-purchased electricity and on-site fuel consumption.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='annual_emissions_tonnes_SO2',
            field=models.FloatField(blank=True, help_text="Average annual total tons of emissions associated with the site's grid-purchased electricity and on-site fuel consumption.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='lifecycle_emissions_from_fuelburn_tonnes_CO2',
            field=models.FloatField(blank=True, help_text="Total tons of CO2e emissions associated with the site's onsite fuel burn over the analysis period.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='lifecycle_emissions_from_fuelburn_tonnes_CO2_bau',
            field=models.FloatField(blank=True, help_text="Total tons of CO2e emissions associated with the site's onsite fuel burn over the analysis period in the BAU case.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='lifecycle_emissions_tonnes_CO2',
            field=models.FloatField(blank=True, help_text="Total tons of CO2e emissions associated with the site's energy consumption over the analysis period.", null=True),
        ),
        migrations.AlterField(
            model_name='siteoutputs',
            name='lifecycle_emissions_tonnes_CO2_bau',
            field=models.FloatField(blank=True, help_text="Total tons of CO2e emissions associated with the site's energy consumption over the analysis period in the BAU case.", null=True),
        ),
        migrations.AlterField(
            model_name='windinputs',
            name='installed_cost_per_kw',
            field=models.FloatField(blank=True, help_text='Installed cost in $/kW. Default cost is determined based on size_class.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100000.0)]),
        ),
        migrations.AlterField(
            model_name='windinputs',
            name='om_cost_per_kw',
            field=models.FloatField(blank=True, default=36, help_text='Annual operations and maintenance costs in $/kW', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000.0)]),
        ),
    ]
