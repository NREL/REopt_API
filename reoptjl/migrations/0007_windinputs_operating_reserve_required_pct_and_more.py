# Generated by Django 4.0.6 on 2022-08-24 15:45

import django.contrib.postgres.fields
import django.core.validators
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('reoptjl', '0006_siteoutputs_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='windinputs',
            name='operating_reserve_required_pct',
            field=models.FloatField(blank=True, help_text='Only applicable when off_grid_flag=True; defaults to 0.5 (50 pct) for off-grid scenarios and fixed at 0 otherwise.Required operating reserves applied to each timestep as a fraction of wind generation serving load in that timestep.', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)]),
        ),
        migrations.AlterField(
            model_name='electricloadinputs',
            name='critical_load_pct',
            field=models.FloatField(blank=True, default=0.5, help_text='Critical load factor is multiplied by the typical load to determine the critical load that must be met during an outage. Value must be between zero and one, inclusive.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(2)]),
        ),
        migrations.AlterField(
            model_name='electricloadinputs',
            name='min_load_met_annual_pct',
            field=models.FloatField(blank=True, help_text='Only applicable when off_grid_flag = True. Fraction of the load that must be met on an annual energy basis.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='electricloadinputs',
            name='operating_reserve_required_pct',
            field=models.FloatField(blank=True, help_text='Only applicable when off_grid_flag=True; defaults to 0.1 (10 pct) for off-grid scenarios and fixed at 0 otherwise.Required operating reserves applied to each timestep as a fraction of electric load in that timestep.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='electricloadoutputs',
            name='offgrid_annual_oper_res_required_series_kwh',
            field=django.contrib.postgres.fields.ArrayField(base_field=models.FloatField(blank=True, null=True), default=list, help_text='Total operating reserves required (for load and techs) on an annual basis, for off-grid scenarios only', size=None),
        ),
        migrations.AlterField(
            model_name='electricutilityinputs',
            name='interconnection_limit_kw',
            field=models.FloatField(blank=True, default=1000000000.0, help_text='Limit on total system capacity that can be interconnected to the grid.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000.0)]),
        ),
        migrations.AlterField(
            model_name='electricutilityinputs',
            name='outage_end_time_step',
            field=models.IntegerField(blank=True, help_text='Time step that grid outage ends. Must be greater than or equal to outage_start_time_step. Use to model a single, deterministic outage.', null=True, validators=[django.core.validators.MinValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='electricutilityinputs',
            name='outage_start_time_step',
            field=models.IntegerField(blank=True, help_text='Time step that grid outage starts. Must be less than or equal to outage_end_time_step. Use to model a single, deterministic outage.', null=True, validators=[django.core.validators.MinValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='financialinputs',
            name='microgrid_upgrade_cost_pct',
            field=models.FloatField(blank=True, help_text='Additional cost, in percent of non-islandable capital costs, to make a distributed energy system islandable from the grid and able to serve critical loads. Includes all upgrade costs such as additional labor and critical load panels. Costs apply only when modeling outages using the outage_start_time_steps, outage_durations, and outage_probabilities inputs, and do not apply when modeling a single outage using outage_start_time_step and outage_end_time_step.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1)]),
        ),
        migrations.AlterField(
            model_name='financialinputs',
            name='offgrid_other_annual_costs',
            field=models.FloatField(blank=True, default=0.0, help_text='Only applicable when off_grid_flag is true. These per year costs are considered tax deductible for owner.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000.0)]),
        ),
        migrations.AlterField(
            model_name='financialinputs',
            name='value_of_lost_load_per_kwh',
            field=models.FloatField(blank=True, default=100, help_text='Value placed on unmet site load during grid outages. Units are US dollars per unmet kilowatt-hour. The value of lost load (VoLL) is used to determine the avoided outage costs by multiplying VoLL [$/kWh] with the average number of hours that the critical load can be met by the energy system (determined by simulating outages occuring at every hour of the year), and multiplying by the mean critical load. Costs apply only when modeling outages using the outage_start_time_steps, outage_durations, and outage_probabilities inputs, and do not apply when modeling a single outage using outage_start_time_step and outage_end_time_step.', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000.0)]),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_MG_upgrade_and_fuel_cost',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). This is the cost to upgrade generation and storage technologies to be included in microgridplus present value of microgrid fuel costs.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_chp_standby_cost_after_tax',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). This value is the present value of all CHP standby charges, after tax.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_elecbill_after_tax',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). This value is the present value of all electric utility charges, after tax.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_fuel_costs_after_tax',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). This value is the present value of all fuel costs over the analysis period, after tax.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_generation_tech_capital_costs',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). Net capital costs for all generation technologies.Costs are given in present value, including replacement costs and incentives.This value does not include offgrid_other_capital_costs.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_offgrid_other_annual_costs_after_tax',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). This value is the present value of offgrid_other_annual_costs over the analysis period, after tax.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_offgrid_other_capital_costs',
            field=models.FloatField(blank=True, help_text="Component of lifecycle costs (LCC). This value is equal to offgrid_other_capital_costs with straight line depreciation applied over the analysis period. The depreciation expense is assumed to reduce the owner's taxable income.", null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_om_costs_after_tax',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). This value is the present value of all O&M costs, after tax.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_outage_cost',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). Expected outage cost.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_production_incentive_after_tax',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). This value is the present value of all production-based incentives, after tax.', null=True),
        ),
        migrations.AlterField(
            model_name='financialoutputs',
            name='lifecycle_storage_capital_costs',
            field=models.FloatField(blank=True, help_text='Component of lifecycle costs (LCC). Net capital costs for all storage technologies.Value is in present value, including replacement costs and incentives.This value does not include offgrid_other_capital_costs.', null=True),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='fuel_avail_gal',
            field=models.FloatField(blank=True, help_text='On-site generator fuel available in gallons per year.', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1000000000.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='fuel_intercept_gal_per_hr',
            field=models.FloatField(blank=True, default=0.0, help_text='Generator fuel consumption curve y-intercept in gallons per hour.', validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(10.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='min_turn_down_pct',
            field=models.FloatField(blank=True, help_text='Minimum generator loading in percent of capacity (size_kw).', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='om_cost_per_kw',
            field=models.FloatField(blank=True, help_text='Annual diesel generator fixed operations and maintenance costs in $/kW', null=True, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1000.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='replace_cost_per_kw',
            field=models.FloatField(blank=True, help_text='Per kW replacement cost for generator capacity. Replacement costs are considered tax deductible.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000.0)]),
        ),
        migrations.AlterField(
            model_name='generatorinputs',
            name='replacement_year',
            field=models.IntegerField(blank=True, help_text='Project year in which generator capacity will be replaced at a cost of replace_cost_per_kw.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(100)]),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='azimuth',
            field=models.FloatField(blank=True, help_text='PV azimuth angle', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(360)]),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='can_export_beyond_nem_limit',
            field=models.BooleanField(blank=True, default=True, help_text='True/False for if technology can export energy beyond the annual site load (and be compensated for that energy at the export_rate_beyond_net_metering_limit).Note that if off-grid is true, can_export_beyond_nem_limit is always set to False.'),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='can_net_meter',
            field=models.BooleanField(blank=True, default=True, help_text='True/False for if technology has option to participate in net metering agreement with utility. Note that a technology can only participate in either net metering or wholesale rates (not both).Note that if off-grid is true, net metering is always set to False.'),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='can_wholesale',
            field=models.BooleanField(blank=True, default=True, help_text='True/False for if technology has option to export energy that is compensated at the wholesale_rate. Note that a technology can only participate in either net metering or wholesale rates (not both).Note that if off-grid is true, can_wholesale is always set to False.'),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='max_kw',
            field=models.FloatField(blank=True, default=1000000000.0, help_text='Maximum PV size constraint for optimization (upper bound on additional capacity beyond existing_kw). Set to zero to disable PV', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000.0)]),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='min_kw',
            field=models.FloatField(blank=True, default=0, help_text='Minimum PV size constraint for optimization (lower bound on additional capacity beyond existing_kw).', validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1000000000.0)]),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='operating_reserve_required_pct',
            field=models.FloatField(blank=True, help_text='Only applicable when off_grid_flag=True; defaults to 0.25 (25 pct) for off-grid scenarios and fixed at 0 otherwise.Required operating reserves applied to each timestep as a fraction of PV generation serving load in that timestep.', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(1.0)]),
        ),
        migrations.AlterField(
            model_name='pvinputs',
            name='tilt',
            field=models.FloatField(blank=True, help_text='PV system tilt. If PV system type is rooftop-fixed, then tilt=10 degrees, else abs(site.latitude)', null=True, validators=[django.core.validators.MinValueValidator(0), django.core.validators.MaxValueValidator(90)]),
        ),
        migrations.AlterField(
            model_name='settings',
            name='off_grid_flag',
            field=models.BooleanField(blank=True, default=False, help_text='Set to true to enable off-grid analyses, not connected to a bulk power system.'),
        ),
        migrations.AlterField(
            model_name='siteinputs',
            name='latitude',
            field=models.FloatField(help_text='The latitude of the site in decimal degrees.', validators=[django.core.validators.MinValueValidator(-90), django.core.validators.MaxValueValidator(90)]),
        ),
        migrations.AlterField(
            model_name='siteinputs',
            name='longitude',
            field=models.FloatField(help_text='The longitude of the site in decimal degrees.', validators=[django.core.validators.MinValueValidator(-180), django.core.validators.MaxValueValidator(180)]),
        ),
        migrations.AlterField(
            model_name='windinputs',
            name='can_export_beyond_nem_limit',
            field=models.BooleanField(blank=True, default=True, help_text='True/False for if technology can export energy beyond the annual site load (and be compensated for that energy at the export_rate_beyond_net_metering_limit).Note that if off-grid is true, can_export_beyond_nem_limit is always set to False.'),
        ),
        migrations.AlterField(
            model_name='windinputs',
            name='can_net_meter',
            field=models.BooleanField(blank=True, default=True, help_text='True/False for if technology has option to participate in net metering agreement with utility. Note that a technology can only participate in either net metering or wholesale rates (not both).Note that if off-grid is true, net metering is always set to False.'),
        ),
        migrations.AlterField(
            model_name='windinputs',
            name='can_wholesale',
            field=models.BooleanField(blank=True, default=True, help_text='True/False for if technology has option to export energy that is compensated at the wholesale_rate. Note that a technology can only participate in either net metering or wholesale rates (not both).Note that if off-grid is true, can_wholesale is always set to False.'),
        ),
    ]
